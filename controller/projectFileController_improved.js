import ProjectFile from "../model/projectFile.js";
import Project from "../model/project.js";
import ProjectPurchase from "../model/projectPurchase.js";
import User from "../model/user.js";
import { Op } from "sequelize";
import sequelize from "../config/db.js";
import {
  sendSuccess,
  sendError,
  sendValidationError,
  sendNotFound,
  sendServerError,
} from "../utils/responseHelper.js";

// ===================== IMPROVED PROJECT FILE MANAGEMENT =====================

/**
 * Save project files to database (after upload via file upload API)
 * This endpoint expects file information from the upload API response
 */
export const saveProjectFiles = async (req, res) => {
  const transaction = await sequelize.transaction();

  try {
    const { projectId } = req.params;
    const { files } = req.body; // Array of file objects from upload API
    const userId = req.user.userId;

    // Validate project exists and user has permission
    const project = await Project.findByPk(projectId);
    if (!project) {
      await transaction.rollback();
      return sendNotFound(res, "Project not found");
    }

    // Check if user is creator or admin
    if (project.createdBy !== userId && req.user.role !== "admin") {
      await transaction.rollback();
      return sendError(res, 403, "Not authorized to upload files for this project");
    }

    // Validate files array
    if (!files || !Array.isArray(files) || files.length === 0) {
      await transaction.rollback();
      return sendValidationError(res, "No file information provided");
    }

    const savedFiles = [];

    // Process each file
    for (const fileInfo of files) {
      // Validate required file information
      if (!fileInfo.url || !fileInfo.originalName || !fileInfo.fileId) {
        continue; // Skip invalid files
      }

      // Determine file type based on extension or mime type
      const fileExtension = fileInfo.originalName
        ? fileInfo.originalName.split('.').pop().toLowerCase()
        : '';
      
      let fileType = "other";
      if ([".zip", ".rar", ".7z", ".tar", ".gz"].includes(`.${fileExtension}`)) {
        fileType = "archive";
      } else if (
        [".js", ".ts", ".html", ".css", ".php", ".py", ".java", ".cpp", ".c"]
          .includes(`.${fileExtension}`)
      ) {
        fileType = "source_code";
      } else if (
        [".pdf", ".doc", ".docx", ".txt", ".md"].includes(`.${fileExtension}`)
      ) {
        fileType = "documentation";
      } else if (
        [".jpg", ".jpeg", ".png", ".gif", ".svg", ".webp"]
          .includes(`.${fileExtension}`)
      ) {
        fileType = "image";
      } else if (
        [".mp4", ".avi", ".mov", ".wmv", ".flv"].includes(`.${fileExtension}`)
      ) {
        fileType = "video";
      }

      // Create file record in database
      const projectFile = await ProjectFile.create(
        {
          projectId: projectId, // Keep as string/UUID
          fileName: fileInfo.originalName,
          fileUrl: fileInfo.url, // Use S3 URL - correct field name
          fileType: fileType,
          fileSize: fileInfo.fileSize || 0,
          mimeType: fileInfo.mimeType || "application/octet-stream",
          description: fileInfo.description || "",
          downloadCount: 0,
          uploadedBy: userId,
          // Note: fileId is auto-generated by the model, don't set external fileId
        },
        { transaction }
      );

      savedFiles.push(projectFile);
    }

    await transaction.commit();

    // Fetch saved files with associations for response
    const filesWithDetails = await ProjectFile.findAll({
      where: {
        fileId: { [Op.in]: savedFiles.map((f) => f.fileId) },
      },
      include: [
        {
          model: User,
          as: "uploader",
          attributes: ["userId", "username", "email"],
        },
      ],
    });

    sendSuccess(
      res,
      `${savedFiles.length} file(s) saved successfully`,
      {
        files: filesWithDetails,
        projectId: projectId
      }
    );
  } catch (error) {
    try {
      await transaction.rollback();
    } catch (rollbackError) {
      console.error("Transaction rollback error:", rollbackError);
    }
    console.error("Save project files error:", error);
    sendServerError(res, "Failed to save files", error.message);
  }
};

/**
 * Get project files (improved version with better access control)
 */
export const getProjectFiles = async (req, res) => {
  try {
    const { projectId } = req.params;
    const { fileType, page = 1, limit = 50 } = req.query;
    const userId = req.user?.userId;

    // Validate project exists
    const project = await Project.findByPk(projectId);
    if (!project) {
      return sendNotFound(res, "Project not found");
    }

    // Build where condition
    const whereCondition = { projectId: projectId };
    if (fileType && fileType !== 'all') {
      whereCondition.fileType = fileType;
    }

    // Check user access permissions
    let hasFullAccess = false;
    
    if (userId) {
      // Check if user is admin, project creator, or has purchased the project
      if (req.user.role === 'admin' || project.createdBy === userId) {
        hasFullAccess = true;
      } else {
        // Check if user has purchased the project
        const purchase = await ProjectPurchase.findOne({
          where: { projectId: projectId, userId: userId }
        });
        hasFullAccess = !!purchase;
      }
    }

    // If no access, only show preview files
    if (!hasFullAccess) {
      whereCondition.isPreview = true;
    }

    // Calculate pagination
    const offset = (parseInt(page) - 1) * parseInt(limit);

    // Fetch files with pagination
    const { rows: files, count: totalFiles } = await ProjectFile.findAndCountAll({
      where: whereCondition,
      include: [
        {
          model: User,
          as: "uploader",
          attributes: ["userId", "username"],
        },
      ],
      order: [["createdAt", "DESC"]],
      limit: parseInt(limit),
      offset: offset,
    });

    const response = {
      files,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(totalFiles / parseInt(limit)),
        totalFiles,
        limit: parseInt(limit),
        hasNext: offset + files.length < totalFiles,
        hasPrev: parseInt(page) > 1
      },
      access: {
        hasFullAccess,
        isPreviewOnly: !hasFullAccess
      }
    };

    sendSuccess(res, "Project files retrieved successfully", response);
  } catch (error) {
    console.error("Get project files error:", error);
    sendServerError(res, "Failed to retrieve files", error.message);
  }
};

/**
 * Delete project file (Admin/Creator only)
 */
export const deleteProjectFile = async (req, res) => {
  const transaction = await sequelize.transaction();

  try {
    const { projectId, fileId } = req.params;
    const userId = req.user.userId;

    // Validate project exists
    const project = await Project.findByPk(projectId);
    if (!project) {
      await transaction.rollback();
      return sendNotFound(res, "Project not found");
    }

    // Check if user is creator or admin
    if (project.createdBy !== userId && req.user.role !== "admin") {
      await transaction.rollback();
      return sendError(res, 403, "Not authorized to delete files for this project");
    }

    // Find and delete the file
    const projectFile = await ProjectFile.findOne({
      where: { id: fileId, projectId: projectId }
    });

    if (!projectFile) {
      await transaction.rollback();
      return sendNotFound(res, "File not found");
    }

    await projectFile.destroy({ transaction });
    await transaction.commit();

    sendSuccess(res, "File deleted successfully", { 
      deletedFile: {
        id: projectFile.id,
        fileName: projectFile.fileName
      }
    });
  } catch (error) {
    await transaction.rollback();
    console.error("Delete project file error:", error);
    sendServerError(res, "Failed to delete file", error.message);
  }
};

/**
 * Update project file metadata (Admin/Creator only)
 */
export const updateProjectFile = async (req, res) => {
  const transaction = await sequelize.transaction();

  try {
    const { projectId, fileId } = req.params;
    const { fileName, description, isPreview } = req.body;
    const userId = req.user.userId;

    // Validate project exists
    const project = await Project.findByPk(projectId);
    if (!project) {
      await transaction.rollback();
      return sendNotFound(res, "Project not found");
    }

    // Check if user is creator or admin
    if (project.createdBy !== userId && req.user.role !== "admin") {
      await transaction.rollback();
      return sendError(res, 403, "Not authorized to update files for this project");
    }

    // Find and update the file
    const projectFile = await ProjectFile.findOne({
      where: { id: fileId, projectId: projectId }
    });

    if (!projectFile) {
      await transaction.rollback();
      return sendNotFound(res, "File not found");
    }

    // Update fields if provided
    if (fileName !== undefined) projectFile.fileName = fileName;
    if (description !== undefined) projectFile.description = description;
    if (isPreview !== undefined) projectFile.isPreview = isPreview;

    await projectFile.save({ transaction });
    await transaction.commit();

    // Fetch updated file with associations
    const updatedFile = await ProjectFile.findByPk(projectFile.id, {
      include: [
        {
          model: User,
          as: "uploader",
          attributes: ["userId", "username"],
        },
      ],
    });

    sendSuccess(res, "File updated successfully", updatedFile);
  } catch (error) {
    await transaction.rollback();
    console.error("Update project file error:", error);
    sendServerError(res, "Failed to update file", error.message);
  }
};
